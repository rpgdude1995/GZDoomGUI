class GuiHandler : EventHandler
{

const INIT_TICK = 1;

	//Textures
	ui TextureID ibag;
	ui TextureID mag;
	ui TextureID batt;
	ui TextureID invitem;
	ui TextureID cursor;
	ui TextureID HoverCursor;
	ui TextureID HoldCursor;
	ui TextureID invicon;
	ui TextureID invleft;
	ui TextureID invright;
	ui TextureID inactive;
	ui TextureID toggled;
	ui TextureID active;
	ui TextureID Background;
	//Engien nececitys
	ui bool ToggleUI;
	ui playerpawn p;
	ui playerinfo pi;
	ui bool initialized;
	//Coordinates
	ui double x;
	ui double y;	
	ui double xHold;
	ui double yHold;
	//resolution
	ui double Hres;
	ui double Vres;
	//dropdown menu 
	ui bool contextToggle;
	ui bool hover;
	ui bool WeapHover;
	ui bool SlotHover;
	ui bool CacheWeapon;
	ui bool CacheSlot;
	ui bool Dragging;
	ui bool hold;
	ui bool use;
	ui bool drop;
	ui bool equip;
	ui bool weapdrop;
	ui int hoverAreaX;
	ui int hoverAreaY;
	ui bool weapinvDropDownHold;
	ui bool invDropDownHold;
	//Inventory Cacheing
	ui inventory invCache[99];
	ui TextureID iconCache[99];
	ui inventory WeapCache[99];
	ui TextureID IconWeapCache[99];
	ui inventory SlotCache[99];
	ui int slots[99];
	//Inventory Management 
	ui int sel;
	ui int Dropsel;
	ui int WeapSel;
	ui int SlotSel;
	ui int holdSel;
	ui int DragSel;
	ui int invcount;
	ui int location;			
	ui int activeWeaponSlot;
	ui int clickDelay;

	ui void Init()
	{
			//needed for ui to read form player context
			//without results in vm exicution error
			ToggleUI = False;
			pi = players[consoleplayer];
			
			p = playerpawn(pi.mo);
			hover = false;
			slothover = false;
		//	Cellhover = false;
			hold = false;
			Dragging = False;
			weapinvDropDownHold = false;
			invDropDownHold =false;
			contextToggle = False;
			x = 0;
			y = 0;
			Vres = Screen.GetWidth();
			Hres = Screen.GetHeight();
			initialized = TRUE;
			inactive = texman.checkfortexture("inactive",0);
			toggled = texman.checkfortexture("toggled",0);
			active = texman.checkfortexture("invsel",0);
			Background = texman.checkfortexture("Bag",0);
			Cursor = texman.checkfortexture("Arrow",0);
			HoverCursor = texman.checkfortexture("Finger",0);
			HoldCursor = texman.checkfortexture("Hand",0);		
			FillSlotCache();
			
			//this replicates default bindings for doom
			slots[0] = 0; //fists
			slots[1] = 1; //chainsaw
			slots[2] = 2; //pistol
			slots[3] = 17; //no default
			slots[4] = 4; //super shotgun
			slots[5] = 3; //shotgun
			slots[6] = 5; //chaingun
			slots[7] = 17; //no default
			slots[8] = 6; //rocket launcher
			slots[9] = 17; //no default
			slots[10] = 7; //plasma gun
			slots[11] = 17; //no default 
			slots[12] = 8;	//BFG9000
			slots[13] = 17;	//no default 
			slots[14] = 17; //no default 
			slots[15] = 17; //no default 
			slots[16] = 17; //no default 
			slots[17] = 17; //no default 
		/*	
				//Cleared Bindings
			slots[0] = 0; //no default 
			slots[1] = 0; //no default 
			slots[2] = 0; //no default 
			slots[3] = 0; //no default
			slots[4] = 0; //no default 
			slots[5] = 0; //no default 
			slots[6] = 0; //no default 
			slots[7] = 0; //no default
			slots[8] = 0; //no default 
			slots[9] = 0; //no default
			slots[10] = 0; //no default 
			slots[11] = 0; //no default 
			slots[12] = 0; //no default 
			slots[13] = 0;	//no default 
			slots[14] = 0; //no default 
			slots[15] = 0; //no default 
			slots[16] = 0; //no default 
			slots[17] = 0; //no default 
		*/	
	}
	
	//Gui Toggle
	override void consoleProcess(ConsoleEvent event)
	{
		if (event.name == "INV_Open")
		{
			ToggleUI = !ToggleUI;
		}
	}

	ui int getItemsNumber()
	{
		let item   = players[consolePlayer].mo.inv;
		int result = 0;
		while (item != NULL)
		{
			result += item.bInvBar;
			item = item.inv;
		}
		return result;
	}	
			
	ui int getItemsIndex()
	{
		let item   = p.invsel;
		int result = getItemsNumber() + 1;
		while (item != NULL)
		{
			result -= item.bInvBar;
			item = item.inv;
		}
		return result;
	}
	
	ui int InvSize()
	{
		let item   = p.invFirst; 
		int result = getItemsNumber() + 1;
		
		if(item != NULL) 
		{
			while (item == pi.mo.invFirst)
			{
				result -= item.bInvBar;
				item = item.inv;
			}
			return result;
		}
		else
		{
			return 0;
		}
			
	}
	
	ui void inventorycache()//puts item in array for easy manipulation
	{
		bool type;
		int index;
		let rover = players[consolePlayer].mo.inv;//pi.mo.invFirst;
		int i = 0;
		int j = 0;
		int x = 0;
		
		if(rover!=NULL)
		{				
			for(i = 0; i < invSize() && rover; rover = rover.NextInv())
			{	
				if((rover.amount > 0) && (rover.binvbar == True))
				{
					iconCache[i] = (BaseStatusBar.getInventoryIcon(rover, BaseStatusBar.DI_ALTICONFIRST));
					invCache[i] = rover;
					i++;		
				}			
				if(invCache[i] == invCache[i + 1])
				{	
					invCache[i + 1] = Null;
				}		
				if(invCache[0] == invCache[1])
				{
					invCache[1] = Null;
				}		
				if(invCache[i] != Null)
					{

					}
				
			}					
		}
		if(rover==null)
		{
			invCache[i] = Null;
		}
		if(players[consolePlayer].mo.invsel == null)
		{
			invCache[0] = null;
		}
	}
	
	ui void Weaponcache()//puts Weapons in array for easy manipulation
	{
		int tw;
		int tq;
		int index = 0;
		
		for(int tw = 1; Tw <= 9; tw++)
		{
			for(int tq = 0; tq <= 9; tq++)
			{	
				if(pi.mo.FindInventory(pi.weapons.GetWeapon(tw, tq)) != Null)
				{
					WeapCache[index] = Weapon(pi.mo.FindInventory(pi.weapons.GetWeapon(tw, tq)));
					IconWeapCache[index] = StatusBar.GetInventoryIcon(WeapCache[index], StatusBar.DI_ALTICONFIRST);
					
				index++;
				}
				else
				{
					WeapCache[index] = null;			
				}

			}
		}	
	}		
	
	ui void FillSlotcache()//puts Weapons in array for easy manipulation
	{
		int tw;
		int tq;
		int index = 0;
		for(int tw = 1; Tw <= 9; tw++)
		{
			for(int tq = 0; tq <= 9; tq++)
			{	
				if(pi.mo.FindInventory(pi.weapons.GetWeapon(tw, tq)) != Null )
				{
					SlotCache[index] = Weapon(pi.mo.FindInventory(pi.weapons.GetWeapon(tw, tq)));
					index++;				
				}
						
			}
		}	
	}	
	
		ui void drawSingleCell(textureID tex, int CellX, int Celly, float alpha)
		{
			int texHeight;
			double tempHeight;
			int texWidth;
			double tempWidth;
			int a;
			double aspectRatio;
			[tempWidth, tempHeight] = texman.Getsize(tex); 
			tempHeight = texman.CheckRealHeight(tex);
			aspectRatio = tempWidth / tempHeight;
			
			if((tempWidth == tempHeight)) 
			{
				tempWidth = 48;
				tempHeight = 48;
			}
			if(aspectRatio > 0)
			{
				tempWidth = 48.0;
				tempHeight = tempWidth / aspectRatio;
			}
			if(aspectRatio < 0)
			{
				tempHeight = 48.0;
				tempWidth = tempHeight * aspectRatio;
			}
			
			texHeight = tempHeight;
			texWidth = tempWidth;
			
			Screen.DrawTexture(tex, false, CellX, Celly, DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, texWidth, DTA_DestHeight, texHeight, DTA_Alpha, alpha, DTA_CenterOffset, DTA_CenterBottomOffset);
		}
	
		ui void drawCell(int posX, int posY, int type, int columnsX, int rowsY)
		{
		
			int view = columnsX * rowsY;
			int i = 0;
			int j = 0;
			int CellX;
			int CellY;
			int index;
			bool DrawHold = false;
			
			inventory CellCache[99];			
			TextureID CellCache2[99];			
			ibag = texman.checkfortexture("ibag",0);
			active = texman.checkfortexture("invsel",0);
			toggled = texman.checkfortexture("toggled",0);
			Inactive = texman.checkfortexture("inactive",0);
			Background = texman.checkfortexture("bag",0);
			
			
			if(type == 1)
			{
				Hover = false;
			}
			if(type == 2)
			{
				weapHover = false;
			}
			if(type == 3)
			{
				slotHover = false;
			}
			
			Screen.DrawTexture(background, false, posx-50, posy-37, DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, columnsX*100, DTA_DestHeight, RowsY*75);

			switch(type)
			{
				
				case 1://inventory
				
				screen.DrawText(BIGFONT, Font.CR_ORANGE, posx-25, posy-45, "INVENTORY ITEMS", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
				for(i = 0; i < 99; i++)
				{	
					CellCache[i] = invCache[i];		
					CellCache2[i] = StatusBar.getInventoryIcon(invCache[i] ,BaseStatusBar.DI_ALTICONFIRST);	
					
					if(CellCache[i] != Null)
					{

					}
				}
				
				CellX = columnsX;
				CellY = rowsY;
				
				break;
				
				
				case 2://weapons
				
				screen.DrawText(BIGFONT, Font.CR_ORANGE, posx-25, posy-45, "WEAPONS", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
				for(i = 0; i < 99; i++)
				{	
					CellCache[i] = weapcache[i];							
					CellCache2[i] = StatusBar.getInventoryIcon(WeapCache[i] ,BaseStatusBar.DI_ALTICONFIRST);	
				}

				CellX = columnsX;
				CellY = rowsY;

				break;
				
				case 3://weapon slots

				screen.DrawText(BIGFONT, Font.CR_ORANGE, posx-25, posy-45, "WEAPON SLOTS", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
				for(i = 0; i < 99; i++)
				{							
					CellCache[i] = weapCache[slots[i]];							
					CellCache2[i] = StatusBar.getInventoryIcon(Weapon(weapCache[slots[i]]) ,BaseStatusBar.DI_ALTICONFIRST);
				}
				CellX = columnsX;
				CellY = rowsY;

				break;
			
			}

			
				//	CellHover = False;
					
					if(ContextToggle == false)
					{
						invDropDownHold = false;
						weapinvDropDownHold = false;
					}
					
					for(i = 0; (i <= CellX) ; i++)
					{	
					
					weapsel = index;
					
						if(CellX != i && CellY != j)
						{
							Screen.DrawTexture(Toggled, false, posx+(i*100), posy+(j*75), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 64, DTA_DestHeight, 48, DTA_Alpha, 0.2, DTA_CenterOffset, DTA_CenterBottomOffset);																				
						}
						
						if(SlotCache[index] == pi.ReadyWeapon && Type == 2 )
						{
							Screen.DrawTexture(active, false, posx+(i*100), posy+(j*75), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 100, DTA_DestHeight, 75,DTA_CenterOffset, DTA_CenterBottomOffset, DTA_FillColor, 0xffffff);
							drawSingleCell(CellCache2[index], posx+(i*100), posy+(j*75), .3);
						}
					
						if(CellX != i && CellY != j)
						{
						
							if(type == 3 && j == CellY -1)// only to label slots for type weapon slots
							{
								screen.DrawText(BIGFONT, Font.CR_YELLOW, posx+(i*100)-40, posy+(j*75)+25, string.format(" Slot %g",i+1), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
							}
						
							if(CellCache[index] != NULL) // Fill unselected icons and tiles
							{

								if(type == 1 && invCache[index] != null)// only need item ammount when dealing with inventory
								{
									screen.DrawText(BIGFONT, Font.CR_YELLOW, posx+(i*100)+25, posy+(j*75)+15, string.format("%g",CellCache[index].amount), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);

								}
								if(type == 2)// show ammo ammounts
								{
									//screen.DrawText(BIGFONT, Font.CR_YELLOW, posx+(i*100)+25, posy+(j*75)+15, string.format("%g",CellCache[index].ammotype.amount), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
								}
								
								
								drawSingleCell(CellCache2[index], posx+(i*100), posy+(j*75), .3);

							}
	
							if(CellCache[index] == p.invsel && Type == 1 && invSize() != 0) // highlight selected (active inventory) icons
							{
								Screen.DrawTexture(active, false, posx+(i*100), posy+(j*75), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 100, DTA_DestHeight, 75,DTA_CenterOffset, DTA_CenterBottomOffset, DTA_FillColor, 0xffffff);
								drawSingleCell(CellCache2[index], posx+(i*100), posy+(j*75), 1);
								
							}
							
							
						}
						
						if((posx + (i * 100)- 55) <= x && x <= (posx + (i * 100) + 45) && (posy + (j * 75)) - 37 <= y && y <= (posy + (j * 75) + 37) && CellX != i && CellY != j)
						{	
							
							if(type == 1 && cellcache[index] != Null && invcache[index] != Null && invSize() != 0)//inventory
							{
								Hover = true;
							}
								
							if(type == 2 && cellcache[weapsel] != null)//weapons
							{
								weapHover = true;
								
								if(cellcache[weapsel] != null)
								{

								}
								if(hold == true && WeapHover == True)
								{

									if(CacheWeapon == True)
									{
										DragSel = weapSel;
										console.printf("dragsel %.2f",dragsel);
										
									}
									CacheWeapon = False;
								}
								
							}
								
							if(type == 3 && (cellcache[index] != NULL || hold == true))//weapon slots
							{
								slotHover = true;
								slotsel = index;

								if(hold == true && CacheSlot == True && SlotHover == True)
								{
									if(CacheSlot == True)
									{

									}
									CacheSlot = False;
								}
								
							}
							if(Dragging == true && type == 3) // draws weapon to slot when dragging
							{								
								drawSingleCell(baseStatusBar.getInventoryIcon(Weapon(SlotCache[DragSel]) ,BaseStatusBar.DI_ALTICONFIRST), posx+(i*100), posy+(j*75), 1);
							}
							
							if(contextToggle == True && (hover == true || weapHover == true || slotHover == true))
							{
								DropSel = sel;

							}	
							if(contextToggle == True && (hover == true || weapHover == true || slotHover == true))
							{
								contexttoggle = false;
							}
							
							if(contexttoggle == false)//Highlight on Hover
							{
								drawSingleCell(CellCache2[index], posx+(i*100), posy+(j*75), 1);
								sel = index;  
								DrawHold = true;
							}
							
							
						}
						
						switch(type)
						{
						
						case 1:
							if(i >= CellX -1  && CellY >= 1 && CellY != j && i != CellX) // once current row is written write next row
							{
								if(j <= CellY && j != CellY)
								{
									j++;
									i = -1;
								}	
							}
						break;
						
						case 2:
							if(i >= CellX -1  && CellY >= 1 && CellY != j && i != CellX) // once current row is written write next row
							{
								if(j <= CellY && j != CellY)
								{
									j++;
									i = -1;
								}	
							}
						break;
						
						case 3: // weapon slots should mirror keyboard number keys writing slots top down then left right
						
							if(j != CellY)
							{
								i--;
								j++;
							}
							if(j == CellY)
							{
								i++;
								j = 0;
							}
							
						break;
						}

						
						if(CacheWeapon == true)
						{
							console.printf("CacheSlot %.2f, SlotHover %.2f, weapsel %.2f, cacheweapon %.2f,dragsel %.2f", CacheSlot, SlotHover, weapsel, CacheWeapon,dragSel);
						}
						
						if(DrawHold == TRUE && CellCache[sel] != NULL && Type != 3) // hover text
						{
							screen.DrawText(BIGFONT, 4, x+40, y+35, CellCache[sel].getclassname(), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
							//DragSel = SlotSel;
							dropsel = sel;
							
						}
						
						if(contextToggle == TRUE && CellCache[DropSel] == CellCache[index] && invDropDownHold == true) // highligts dropdown selection
						{
							drawSingleCell(CellCache2[dropsel], posx+(i*100), posy+(j*75), 1);
						}

						index++;		
					}
		
		}
	
		ui void drawHud(int posX, int posY, int type, int columnsX, int rowsY)
		{
		
		}
	
	
		ui void drawMouse()
		{

			if(Weaphover == false && hover == false && SlotHover == false && hold == false)
			{
			
			cursor = texman.checkfortexture("arrow",0);
			Screen.DrawTexture(cursor, false, x, y,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 64, DTA_DestHeight, 64);
			
			}
			if((WeapHover == True || SlotHover == True || hover == True ) && hold == false)
			{
				HoverCursor = texman.checkfortexture("Finger",0);
				Screen.DrawTexture(HoverCursor, false, x, y,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 64, DTA_DestHeight, 64);

			}
			
			if(hold == true)
			{
			
				HoldCursor = texman.checkfortexture("hand",0);

				if(WeapHover == True || CacheWeapon == False  || CacheSlot == False)
				{
					drawSingleCell(baseStatusBar.getInventoryIcon(weapCache[DragSel] ,BaseStatusBar.DI_ALTICONFIRST), x-10, y+30, 1);
					Dragging = true;
				}
				if(WeapHover == True || SlotHover == True || CacheWeapon == False || CacheSlot == False)
				{
					drawSingleCell(baseStatusBar.getInventoryIcon(weapCache[DragSel] ,BaseStatusBar.DI_ALTICONFIRST), x-10, y+30, 1);
					Dragging = true;
				}							
				if(SlotHover == True || CacheWeapon == False  || CacheSlot == False)
				{
					drawSingleCell(baseStatusBar.getInventoryIcon(slotCache[DragSel] ,BaseStatusBar.DI_ALTICONFIRST), x-10, y+30, 1);
					Dragging = true;
				}
				
				Screen.DrawTexture(HoldCursor, false, x, y,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 64, DTA_DestHeight, 64);
				
				
			}
			
		}

		ui void drawDropdown(int xloc, int yloc)
		{
			inactive = texman.checkfortexture("inactive",0);
			toggled = texman.checkfortexture("toggled",0);
			
			use = False;
			Drop = False;
		
			textureid Box1 = toggled;
			textureid Box2 = toggled;
			textureid Box3 = toggled;
			
			int Black = Font.CR_BLACK;
			int Red = Font.CR_RED;
			
			int str1 = Black;
			int str2 = Black;
			int str3 = Black;
			
			xhold = xloc;
			yhold = yloc;

			HUDFont mHUDFont;
			HUDFont mIndexFont;
			HUDFont mAmountFont;
	
			int status;
			
			

			if(hover == true && weaphover == false && ContextToggle == true)
			{
				invDropDownHold = true;
			}
			
			
			//Draw inventory dropdown
			if(invDropDownHold == true && ContextToggle == true)
			{
				if((xloc <= x && x <= xloc + 200) && (yloc <= y && y <= yloc + 48))
				{	
					status = 1;
					use = True;
					Drop = False;
					hover = true;
					weaphover = false;
				}
				else if((xloc <= x && x <= xloc + 200) && (yloc <= y && y <= yloc + 48 + 48))
				{	
					status = 2;
					use = False;
					Drop = True;
					hover = true;			
					weaphover = false;			
				}
				else
				{		
					status = 0;
					use = False;
					Drop = False;
					hover = true;
					weaphover = false;
				}
				
				
				switch(status)
				{
				
					case 0:
					Box1 = toggled;
					Box2 = toggled;
					str1 = Black;
					str2 = Black;	
					break;
				
					case 1:
					Box1 = inactive;
					Box2 = toggled;
					str1 = Red;
					str2 = Black;	
					break;
					
					case 2: 
					Box1 = toggled;
					Box2 = inactive;
					str1 = Black;
					str2 = Red;	
					break;
				
				
				}
				Screen.DrawTexture(Box1, false, xloc, yloc,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 200, DTA_DestHeight, 48);
				screen.DrawText(bigfont, str1, xloc+10, yloc+10, "Use", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
				
				Screen.DrawTexture(Box2, false, xloc, yloc+48,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 200, DTA_DestHeight, 48);
				screen.DrawText(bigfont, str2, xloc+10, yloc+48+10, "Drop", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
						
			}
			
			
			if(weaphover == true && hover == false && ContextToggle == true)
			{
				weapinvDropDownHold = true;
			}
			
			// Draws weapon dropdown
			if(weapinvDropDownHold == true && ContextToggle == true)
			{
				if((xloc <= x && x <= xloc + 200) && (yloc <= y && y <= yloc + 48))
				{	
					status = 1;
					Equip = True;
					weapDrop = False;
					weaphover = true;
					hover = false;
				}
				else if((xloc <= x && x <= xloc + 200) && (yloc <= y && y <= yloc + 48 + 48))
				{	
					status = 2;
					Equip = False;
					weapDrop = True;
					weapHover = true;			
					weapHover = false;			
				}
				else
				{		
					status = 0;
					Equip = False;
					weapDrop = False;
					weaphover = true;
					hover = false;
				}
				
				
				switch(status)
				{
				
					case 0:
					Box1 = toggled;
					Box2 = toggled;
					str1 = Black;
					str2 = Black;
					break;
				
					case 1:
					Box1 = inactive;
					Box2 = toggled;
					str1 = Red;
					str2 = Black;
					break;
					
					case 2: 
					Box1 = toggled;
					Box2 = inactive;
					str1 = Black;
					str2 = Red;
					break;
				
				
				}
				Screen.DrawTexture(Box1, false, xloc, yloc,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 200, DTA_DestHeight, 48);
				screen.DrawText(bigfont, str1, xloc+10, yloc+10, "Equip", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
				
				Screen.DrawTexture(Box2, false, xloc, yloc+48,DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_DestWidth, 200, DTA_DestHeight, 48);
				screen.DrawText(bigfont, str2, xloc+10, yloc+48+10, "Drop", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720);
				
		
						
						{
						
			}
				
			}
		
		}
		
		ui void drawdebug(int xloc, int yloc)
		{
			int list = 0;
	//		screen.DrawText(smallfont, 4, xloc+10, yloc+10, "dropdown values", DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			
	/*		screen.DrawText(smallfont, 4, xloc+10, yloc+(25), string.format("hover"), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(50), string.format("%g",hover), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(75), string.format("context toggle"), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(100), string.format("%g",contexttoggle), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(125), string.format("weap hover"), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(150), string.format("%g",weaphover), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(175), string.format("drop down hold"), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(200), string.format("%g",invDropDownHold), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(225), string.format("weapinvDropDownHold"), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
			screen.DrawText(smallfont, 4, xloc+10, yloc+(250), string.format("%g",weapinvDropDownHold), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
	*/		
			for(int index = 0; index < 99; index++)
			{
				
				//screen.DrawText(smallfont, 4, xloc+10, yloc+(25*index), string.format("%g",index), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
				
				//screen.DrawText(smallfont, 4, xloc+100, yloc+(25*index), string.format("%g",slots[index]), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
				
				if(WeapCache[index] != Null )
				{
					//screen.DrawText(smallfont, 4, xloc+230, yloc+(25*index), WeapCache[index].getclassname(), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
					//screen.DrawText(smallfont, 4, xloc+230, yloc+(25*index), WeapCache[index].getclassname(), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
					list++; 
				}
			}
			
			bool type;
			int index;
			let rover2= players[consolePlayer].mo.inv;//pi.mo.invFirst;
			int i = 0;
			int j = 0;
			int x = 0;
			
			if(rover2!=NULL)
			{				
				for(index = 0; index < invSize() && rover2; rover2 = rover2.NextInv())
				{	
					if(rover2 != NULL)
					{
					//	iconCache[i] = rover2.icon;
					//	iconCache[i] = (BaseStatusBar.getInventoryIcon(rover2, BaseStatusBar.DI_ALTICONFIRST));
						screen.DrawText(smallfont, 4, xloc+230, yloc+(25*index), invcache[index].getclassname(), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
						screen.DrawText(smallfont, 4, xloc+150, yloc+(25*index), string.format("%g",invcache[index].amount), DTA_VirtualWidth, 1280, DTA_VirtualHeight, 720, DTA_CellX, 40, DTA_CellY, 32);
				//		invCache[i] = rover2;
						index++;		
					}										
				}					
			}
			
			
			
			
			
		}

		override void Renderoverlay(RenderEvent e)
		{
			if(initialized == false)
			init();
			if(initialized == true)
			{
			inventorycache();
			WeaponCache();
			fillSlotCache();
			
				if(ToggleUI == true)
				{
					drawCell(300,200,3,7,2);
					drawCell(200,400,2,4,3);
					drawCell(700,400,1,4,3);
				//	drawdebug(30, 60);
					if(contextToggle == true)
					{
						drawdropdown(xhold, yhold);
					}
					
					DrawMouse();
					
				}
			}
		}
		
		override void RenderUnderlay(RenderEvent e)
		{
			if(initialized == false)
			init();
			if(initialized == true)
			{
				if(ToggleUI == true)
				{

				}
			
			}

		}
		
		override bool UiProcess(UiEvent e)
		{
			return true;
		}
		
		override bool InputProcess(InputEvent e)
		{
		
		if(initialized == false)
		return false;
			
			Bool DoubleClick;
			
			int left;
			int right;
			int back;
			int forward;
			int click;
			int altclick;
			//int zoom;
			int i;
			int up;
			int down;
			int Shift;
			int Slot1;
			int Slot2;
			int Slot3;
			int Slot4;
			int Slot5;
			int Slot6;
			int Slot7;
			int Slot8;
			int Slot9;
			
			
			//[ToggleInventory, i] = Bindings.GetKeysForCommand("+user1");
			[left, i] = Bindings.GetKeysForCommand("+moveleft");
			[right, i] = Bindings.GetKeysForCommand("+moveright");
			[forward, i] = Bindings.GetKeysForCommand("+forward");
			[back, i] = Bindings.GetKeysForCommand("+back");
			[click, i] = Bindings.GetKeysForCommand("+attack");
			//[altclick, i] = Bindings.GetKeysForCommand("+altattack");
			[altclick, i] = Bindings.GetKeysForCommand("+zoom");
			x += e.MouseX;
			y -= e.MouseY;
			[up, i] = Bindings.GetKeysForCommand("weapprev");
			[down, i] = Bindings.GetKeysForCommand("weapnext");
			[shift, i] = Bindings.GetKeysForCommand("+speed");
			
			[Slot1, i] = Bindings.GetKeysForCommand("slot 1");
			[Slot2, i] = Bindings.GetKeysForCommand("slot 2");
			[Slot3, i] = Bindings.GetKeysForCommand("slot 3");
			[Slot4, i] = Bindings.GetKeysForCommand("slot 4");
			[Slot5, i] = Bindings.GetKeysForCommand("slot 5");
			[Slot6, i] = Bindings.GetKeysForCommand("slot 6");
			[Slot7, i] = Bindings.GetKeysForCommand("slot 7");
			[Slot8, i] = Bindings.GetKeysForCommand("slot 8");
			[Slot9, i] = Bindings.GetKeysForCommand("slot 9");
			
			if(level.maptime <= clickDelay+17 )
					{
						DoubleClick = true;
						console.Printf("%.2f",clickDelay);
					}
			
			if(level.maptime >= clickDelay+17 )
					{
						DoubleClick = false;
						console.Printf("%.2f",clickDelay);
					}


				if ( e.Type == InputEvent.Type_Mouse && ToggleUI)
				{
					x = max(-215, min(1495, x));
					y = max(0, min(720, y));
					return true;
				}	
				
			
			if(e.Type == InputEvent.Type_KeyDown && ToggleUI)
			{
				
				if(e.KeyScan == click && ToggleUI == true)
				{	
					
					if(contextToggle == true && Use == True)
					{
						
						EventHandler.SendNetworkEvent("UseInv", dropsel);
						console.Printf("%.2f",dropsel);
						contextToggle = false;
						
		
					}
					
					if(DoubleClick == true) // double click
					{
						
						EventHandler.SendNetworkEvent("UseInv", dropsel);
						console.Printf("Doubleclick");
						DoubleClick = false;
						
		
					}
					
					if(contextToggle == true && drop == True)
					{
						
						clickDelay = level.maptime+17;
						EventHandler.SendNetworkEvent("DropInv", dropsel);
						Console.Printf("%.2f",dropsel);
						contextToggle = false;
						
		
					}

					if(contextToggle == false && hover == true && DoubleClick == false)
					{	
						if(clickDelay < level.maptime+17)
						{
							clickDelay = level.maptime;
						}
						console.Printf("%.2i",clickDelay);
						while(invCache[sel] != p.invsel)
						{
							p.invNext();
						
						}
					
					}
					
					if(contextToggle == false && weaphover == true)
					{	
					
					}
					
					if(hover == true)
					{
						hold == False;
					}
					if(weaphover == true  && hold == False)
					{
						CacheWeapon = True;
						Hold = !hold;	
					}
					if(Slothover == true && hold == False)
					{
						CacheSlot = True;
						Hold = !hold;	
					}
					if(slotHover == true && hold == True)
					{	
						Hold = !hold;	
					}
					if(dragging == True && SlotHover == True)
					{
						slots[slotSel] = dragSel;
						dragging = false;		
					}
					hold == False;
					
					
				return true;			
						
				}
				
				if(e.KeyScan == Shift && ToggleUI == true)
				{
					if(hover == true)
					{
						hold == False;
					}
					if(weaphover == true  && hold == False)
					{
						CacheWeapon = True;
						Hold = !hold;	
					}
					if(Slothover == true && hold == False)
					{
						CacheSlot = True;
						Hold = !hold;	
					}
					if(slotHover == true && hold == True)
					{	
						Hold = !hold;	
					}
					if(dragging == True && SlotHover == True)
					{
						slots[slotSel] = dragSel;
						dragging = false;		
					}
					hold == False;
					
					return true;	
				}
				
			
				
				if(e.KeyScan == altclick && hold == True)// deselect held weapon with right click
				{
					hold = false;
					dragging = false;		
					
				}
				
				
				if(e.KeyScan == altclick && ToggleUI == true && (hover == true || weapHover == true))
				{			
					if(e.KeyScan == altclick && Hover == true)
					{
						console.printf("%.2f", dropsel);
						console.printf("%s", invCache[dropsel].getClassname());
						EventHandler.SendNetworkEvent("DropInv", dropsel);
					}	
				
					if(e.KeyScan == altclick && slotHover == true)
					{
				
						console.printf("empty slot");
						console.printf("%.2f", slotsel);
						slots[slotSel] = 0;
				
					}
					
					if(e.KeyScan == altclick && WeapHover == true && dragging == false)// right click drop weapon
					{
						
						console.printf("drop weapon");
						console.printf("%.2f", activeWeaponSlot);
						console.printf("%.2f", weapsel);
						CacheWeapon = true;
						string weap;
						weap.appendformat("DropWeap:%s",weapCache[dropsel].GetClassName());
						console.printf(weap);
						EventHandler.SendNetworkEvent(weap);
						CacheWeapon = false;
				
					}
				
					if(e.Type == InputEvent.Type_KeyDown && use == true && e.KeyScan == click)
					{
						EventHandler.SendNetworkEvent("UseInv", sel);
					}
					if(e.Type == InputEvent.Type_KeyDown && drop == true && e.KeyScan == click)
					{
						EventHandler.SendNetworkEvent("DropInv", sel);
						console.printf("%.2f",sel);
						console.printf("%.2f",invCache[sel].getClassName());
					}
				
					contextToggle = !contextToggle;
					xHold = x;
					yHold = y;

				return true;			
						
				}
				
				
				
				
				//////////////////////////////////////////////////////////////////////
				// captures the rest of the inputs so the player cant move around etc
				/////////////////////////////////////////////////////////////////////
				else if(e.KeyScan == left && ToggleUI)
				{
					if (ToggleUI)
					{
						//EventHandler.SendNetworkEvent("");
						return true;
					}
				}
				else if(e.KeyScan == right && ToggleUI)
				{
					if (ToggleUI)
					{
						//EventHandler.SendNetworkEvent("");
						return true;
					}p.invnext();
				}
				else if(e.KeyScan == back && ToggleUI)
				{
					if (ToggleUI)
					{
						//EventHandler.SendNetworkEvent("");
						return true;
					}
				}
				else if(e.KeyScan == forward && ToggleUI)
				{
					if (ToggleUI)
					{
						//EventHandler.SendNetworkEvent("");
						return true;
					}
				}
				
				
				//////////////////////////////////////////////////////////////////////
				// allows player to mousewheele through inventory items
				/////////////////////////////////////////////////////////////////////
				else if(e.KeyScan == up && ToggleUI)
				{
					
					if (ToggleUI)
					{
						p.invprev();
						invcount++;
						return true;
					}
					
				}
				
				else if(e.KeyScan == down && ToggleUI)
				{
					
					if (ToggleUI)
					{
						p.invnext();
						invcount--;
						return true;
					}
					
				}
							
			}
			
			//////////////////////////////////////////////////////////////////////
			// Overrides the keyboard Weapon slots so they can be rearanged
			/////////////////////////////////////////////////////////////////////
				
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot1)
				{	
					if(WeapCache[slots[0]] != null || WeapCache[slots[1]] != null)
					{
						string weap;

						if(WeapCache[slots[0]] != null && activeWeaponSlot != 0)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[0]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 0;
							return true;	
						}		
		
						if(WeapCache[slots[1]] != null && activeWeaponSlot != 1)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[1]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 1;
							return true;	
						}
					}	
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot2)
				{
					if(WeapCache[slots[2]] != null || WeapCache[slots[3]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[2]] != null && activeWeaponSlot != 2)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[2]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 2;
							return true;	
						}		
		
						if(WeapCache[slots[3]] != null && activeWeaponSlot != 3)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[3]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 3;
							return true;	
						}	
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot3)
				{
					if(WeapCache[slots[4]] != null || WeapCache[slots[5]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[4]] != null && activeWeaponSlot != 4)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[4]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 4;
							return true;	
						}		
		
						if(WeapCache[slots[5]] != null && activeWeaponSlot != 5)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[5]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 5;
							return true;	
						}	
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot4)
				{
					if(WeapCache[slots[6]] != null || WeapCache[slots[7]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[6]] != null && activeWeaponSlot != 6)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[6]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 6;
							return true;	
						}		
		
						if(WeapCache[slots[7]] != null && activeWeaponSlot != 7)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[7]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 7;
							return true;	
						}	
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot5)
				{
					if(WeapCache[slots[8]] != null || WeapCache[slots[9]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[8]] != null && activeWeaponSlot != 8)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[8]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 8;
							return true;	
						}		
		
						if(WeapCache[slots[9]] != null && activeWeaponSlot != 9)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[9]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 9;
							return true;	
						}	
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot6)
				{
					if(WeapCache[slots[10]] != null || WeapCache[slots[11]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[10]] != null && activeWeaponSlot != 10)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[10]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 10;
							return true;	
						}		
		
						if(WeapCache[slots[11]] != null && activeWeaponSlot != 11)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[11]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 11;
							return true;	
						}	
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot7)
				{
					if(WeapCache[slots[12]] != null || WeapCache[slots[13]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[12]] != null && activeWeaponSlot != 12)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[12]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 12;
							return true;	
						}		
		
						if(WeapCache[slots[13]] != null && activeWeaponSlot != 13)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[13]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 13;
							return true;	
						}	
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot8)
				{
					if(WeapCache[slots[14]] != null || WeapCache[slots[15]] != null)
					{
					
						string weap;
					
						if(WeapCache[slots[14]] != null && activeWeaponSlot != 14)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[14]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 14;
							return true;	
						}		
		
						if(WeapCache[slots[15]] != null && activeWeaponSlot != 15)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[15]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 1;
							return true;	
						}
					}
					return true;	
				}
			}
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == slot9)
				{
				
					string weap;
				
					if(WeapCache[slots[16]] != null || WeapCache[slots[17]] != null)
					{
						if(WeapCache[slots[16]] != null && activeWeaponSlot != 16)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[16]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 16;
							return true;	
						}		
		
						if(WeapCache[slots[17]] != null && activeWeaponSlot != 17)
						{
							console.printf("%.2f",activeWeaponSlot);
							weap.appendformat("SwitchWeap:%s",weapCache[slots[1]].GetClassName());
							EventHandler.SendNetworkEvent(weap);
							activeWeaponSlot = 17;
							return true;	
						}
					}
					return true;	
				}
			}
			
			
			//////////////////////////////////////////////////////////////////////
			// Overrides the Mouse Wheele Weapon Select
			/////////////////////////////////////////////////////////////////////
			
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == up)
				{
					string weap;
					
				
					if(slots[activeWeaponSlot] != 0 && activeWeaponSlot != 0)
					{
						activeWeaponSlot--;
					}
					while(slots[activeWeaponSlot] == 0 && activeWeaponSlot != 0)
					{
						activeWeaponSlot--;
					}
					console.printf("%.2f",activeWeaponSlot);
					if(slots[activeWeaponSlot] != 0)
					{
						
						if(weapCache[slots[activeWeaponSlot]] != null)
						{
							weap.appendformat("SwitchWeap:%s",weapCache[slots[activeWeaponSlot]].GetClassName());
							console.printf(weap);
							EventHandler.SendNetworkEvent(weap);
						}
					}
					return true;	
				}
			}
			
			if(e.Type == InputEvent.Type_KeyDown)
			{
				if(e.KeyScan == down)
				{
					string weap;
					
					
					if(slots[activeWeaponSlot] != 0 && activeWeaponSlot != 98)
					{
						activeWeaponSlot++;
					}
					while(slots[activeWeaponSlot] == 0 && activeWeaponSlot != 98)
					{
						activeWeaponSlot++;
					}
					console.printf("%.2f",activeWeaponSlot);
					if(slots[activeWeaponSlot] != 0)
					{
						
						if(weapCache[slots[activeWeaponSlot]] != null)
						{
							weap.appendformat("SwitchWeap:%s",weapCache[slots[activeWeaponSlot]].GetClassName());
							console.printf(weap);
							EventHandler.SendNetworkEvent(weap);
						}
					
					}
					return true;
				}
			}
			
			return false;
		}		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Network events to communicate bettween UI and PLAY Contexts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
override void NetworkProcess(ConsoleEvent e)
	{
	
	
	if (e.IsManual || e.Player < 0 || !PlayerInGame[e.Player] || !(players[e.Player].mo))
			return;

		let player = players [e.Player].mo;
		
		Array<string> command;
		e.Name.Split (command, ":");

		if(command.Size() == 2 && (command [0] ~== "giveitem"))
		{
			player.GiveInventory (command [1], 1);
		}
	
	playerpawn p = playerpawn(players[e.Player].mo);
		
	if ( level.maptime == 0)
	{
		let delay = level.maptime;
	}
	bool switchWeapon;
	bool dropWeapon;
	
	
		let item  = players[consolePlayer].mo.invsel;
		let itemscan  = players[consolePlayer].mo.invFirst;
		int i = 0;
		inventory cache[100];
	
	
		//////////////////////////////////////////////////////////////////////////
		//Inventory Usage
		/////////////////////////////////////////////////////////////////////////
		if(e.Name == "UseInv" && e.Args[0] >= 0 && itemscan != NULL && item != NULL)
		{
			int delay;
			if( level.maptime > delay + 10)
			{
				for(i = 0;itemscan != Null; i++)
				{
					cache[i] = itemscan;
					itemscan = itemscan.Nextinv();

					if(cache[e.Args[0]] != NULL && (i == e.Args[0]))
					{				
						p.useinventory(cache[e.Args[0]]);
						Console.Printf("Use Inventory");
						let delay = level.maptime;
					}	
					
				}
				
			}
		}
		
		if(e.Name == "SwInv" && e.Args[0] != 0 && itemscan != NULL && item != NULL)
		{
			int delay;
			
			Console.Printf("switch Inventory");
			if( level.maptime > delay + 10)
			{
				for(i = 1;itemscan != Null; i++)
				{
					cache[i] = item;
					item = item.Nextinv();
					if(cache[e.Args[0]] != NULL && (i == e.Args[0]))
					{				
						let delay = level.maptime;
					}	
					
				}
				
			}
		}
		
		if(e.Name == "DropInv" && item != NULL && itemscan != NULL)
		{
			int delay;
			if( level.maptime > delay + 10)
			{
				for(i = 0;itemscan != Null; i++)
				{
					cache[i] = itemscan;
					itemscan = itemscan.Nextinv();
					if(cache[e.Args[0]] != NULL && (i == e.Args[0]))
					{				
						p.dropinventory(cache[e.Args[0]],1);
						Console.Printf("Drop inventory");
						let delay = level.maptime;
					}	
					
				}
				
			}
			
		}

		
		///////////////////////////////////////////////////////////////////////
		//droping Weapon Network events 
		///////////////////////////////////////////////////////////////////////
		if(command.Size() == 2 && (command [0] ~== "DropWeap"))
		{
			inventory Dweapon = p.findInventory(command [1]);
			p.dropInventory(Dweapon,1);

		}

		///////////////////////////////////////////////////////////////////////
		//Switching Weapon Network events 
		///////////////////////////////////////////////////////////////////////
		if(command.Size() == 2 && (command [0] ~== "SwitchWeap"))
		{
			p.A_SelectWeapon(command [1]);
		}	
		
	
	}
		
}	
